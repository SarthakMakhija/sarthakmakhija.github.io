<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Refactoring on tech-lessons.in</title><link>/en/tags/refactoring/</link><description>Recent content in Refactoring on tech-lessons.in</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 14 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="/en/tags/refactoring/index.xml" rel="self" type="application/rss+xml"/><item><title>Refactoring Mindset</title><link>/en/blog/refactoring_mindset/</link><pubDate>Tue, 14 Jan 2025 00:00:00 +0000</pubDate><guid>/en/blog/refactoring_mindset/</guid><description>&lt;p>Continuous code improvement is an iterative process. This article focuses on cultivating a &amp;ldquo;refactoring mindset&amp;rdquo; – a deliberate and
proactive approach to consistently improve your code.&lt;/p>
&lt;p>We&amp;rsquo;ll explore key principles like building safety net, making small, frequent changes, recognizing code smells, learning to defer refactoring tasks, and
minimizing bias to maintain a sustainable pace of improvement.&lt;/p>
&lt;p>This article takes the &lt;a href="https://kata-log.rocks/task-list-kata" target="_blank" rel="noopener">TaskList&lt;/a>
 kata, makes minimal modifications to the original kata, and
explains &amp;ldquo;refactoring mindset&amp;rdquo; while refactoring the code. You can find the code that was refactored &lt;a href="https://github.com/SarthakMakhija/task-list-refactoring/tree/original" target="_blank" rel="noopener">here&lt;/a>
.&lt;/p></description></item><item><title>Code without automated tests? Are we serious?</title><link>/en/blog/code_without_tests/</link><pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate><guid>/en/blog/code_without_tests/</guid><description>&lt;p>Automated tests are an essential part of every piece of code that we write. The benefits of these tests are so compelling that it does not even
make sense to think about writing code without tests or writing code today and adding tests later. Despite the benefits, we still see code without tests,
we still see ideas like &amp;ldquo;writing code today and adding tests when the delivery pressure reduces&amp;rdquo; floating around.&lt;/p></description></item><item><title>Let’s deal with Legacy code</title><link>/en/blog/lets_deal_with_legacy_code/</link><pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate><guid>/en/blog/lets_deal_with_legacy_code/</guid><description>&lt;p>This article is in continuation with the &lt;a href="/en/blog/lets_define_legacy_code/">previous article&lt;/a> where we defined some key aspects of Legacy code. In this article we will learn to deal with Legacy code.
Before we begin with an example, let’s take a moment to understand &lt;em class="markup--em markup--p-em">Broken Window Theory.&lt;/em>&lt;/p>&lt;/p>
&lt;img class="align-center" title="Broken Window Theory" src="/broken-window.jpeg" alt="Broken Window Theory" />
&lt;h3 id="broken-window-theory">Broken Window Theory&lt;/h3>
&lt;p>An academic theory proposed by &lt;em>James Q. Wilson and George Kelling&lt;/em> in 1982 that used broken windows as a metaphor for disorder within neighbourhoods.&lt;/p></description></item></channel></rss>