<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on tech-lessons.in</title><link>/en/tags/golang/</link><description>Recent content in Golang on tech-lessons.in</description><generator>Hugo</generator><language>en</language><lastBuildDate>Wed, 22 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="/en/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Many flavors of Networking IO</title><link>/en/blog/many_flavors_of_networking_io/</link><pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate><guid>/en/blog/many_flavors_of_networking_io/</guid><description>&lt;h3 id="introduction">Introduction&lt;/h3>
&lt;p>The foundation of any networked application hinges on its ability to efficiently handle data exchange.
But beneath the surface, there&amp;rsquo;s a hidden world of techniques for managing this communication.
This article dives into various &amp;ldquo;flavors&amp;rdquo; of networking IO, exploring the trade-offs associated with each approach.&lt;/p>
&lt;p>To illustrate various ways applications handle network traffic, we&amp;rsquo;ll build a TCP server using four distinct approaches:
&lt;strong>blocking I/O with a single thread&lt;/strong>, &lt;strong>blocking I/O with multiple threads&lt;/strong>, &lt;strong>non-blocking I/O with busy waiting&lt;/strong>, and
&lt;strong>a single-threaded event loop&lt;/strong>.&lt;/p></description></item><item><title>Cache-Line Hash Table</title><link>/en/blog/cache_line_hash_table/</link><pubDate>Fri, 19 Apr 2024 00:00:00 +0000</pubDate><guid>/en/blog/cache_line_hash_table/</guid><description>&lt;h3 id="introduction">Introduction&lt;/h3>
&lt;p>In the world of multi-core processors, managing concurrent access to data structures is crucial for efficient performance. But frequent updates can trigger a hidden bottleneck: cache coherence traffic. This traffic arises when one core modifies the data another core has cached, forcing updates and invalidation across the system.&lt;/p>
&lt;p>This article dives into a clever solution: the Cache-Line Hash Table (CLHT). CLHTs are specifically designed to minimize this cache coherence traffic, boosting the speed of concurrent data access. We&amp;rsquo;ll explore the core ideas behind CLHTs, including:&lt;/p></description></item><item><title>A guide to Serializable Snapshot Isolation in Key/Value storage engine</title><link>/en/blog/serializable_snapshot_isolation/</link><pubDate>Fri, 22 Mar 2024 00:00:00 +0000</pubDate><guid>/en/blog/serializable_snapshot_isolation/</guid><description>&lt;p>Ensuring data consistency in the face of concurrent transactions is a critical challenge in database management.
Traditional serializable isolation, while guaranteeing data integrity, often suffers from performance bottlenecks due to extensive locking.
This article explores Serializable Snapshot Isolation (SSI) that promises the best of both worlds:
strong data consistency without sacrificing performance.
The article delves into the inner workings of SSI and explore its implementation for a Key/Value storage engine. I will refer to the research
paper titled &lt;a href="https://dl.acm.org/doi/10.1145/2168836.2168853" target="_blank" rel="noopener">A critique of snapshot isolation&lt;/a>
.&lt;/p></description></item><item><title>Invoking C Code from Golang</title><link>/en/blog/invoking_c_from_go/</link><pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate><guid>/en/blog/invoking_c_from_go/</guid><description>&lt;p>The article attempts to explore Golang&amp;rsquo;s &amp;ldquo;C&amp;rdquo; package which allows invoking C code from Golang. Before we get into the idea
of invoking C code from Golang, let&amp;rsquo;s see a use-case where this might be needed.&lt;/p>
&lt;h3 id="interfacing-with-an-existing-c-library">Interfacing with an existing C library&lt;/h3>
&lt;p>Let&amp;rsquo;s consider that we wish to develop a storage engine for pmem (persistent memory) in Golang. In order to develop this, we might want to use
&lt;a href="https://github.com/pmem/pmdk" target="_blank" rel="noopener">pmdk - persistent memory development kit&lt;/a>
 which is written in C. This effectively means we want a way to bridge Golang and C code; invoke C code
from Golang.&lt;/p></description></item></channel></rss>